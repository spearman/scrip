#!/bin/bash

#####################################################################
##  help
#

HELP="\
scrip - file creation utility

scrip <filename> [<filetype>] [flags]
scrip -h, --help
--
    Filetypes
c, c++, md, sh
--
    General flags
-f          force overwrite of existing files
-q          quiet mode: don't list files created
-e          open file(s) for editing
--
    Specific flags

    c, c++
-H          create a header file
-i          include std io files in header
-m [args]   create a source file with main function and
                no header inclusion if filename==main
                args is either 'void' or 'args'
-s          create a source file
-t          create named struct
-u          create pair of files for a compilation unit

    md
-c          table of contents (using markdown_py extension)

    sh
-x          create file with xtrace set
-b [shell]  specify a different shell in /bin/ (default bash)
"

######################################################################
##  make_title ()
#

make_title () {

    # converts characters following whitespace or separators from
    # lowercase to uppercase and replaces separators with whitespace
    # separators are '-' and '_'

    # return variable: string_out

    string_in=$1

    string_in_len=${#string_in}

    last_char=
    read_char=

    string_out=

    for i in $(seq 0 ${string_in_len-1}) ; do
        read_char=${string_in:i:1}

        case $last_char in

            " "|""|-|_)
                this_char="${read_char^}"
            ;;

            *)
                this_char=$read_char
            ;;

        esac

        case $this_char in

            -|_)
                this_char=" "
            ;;

            *)
            ;;

        esac

        string_out=$string_out$this_char

        last_char=$this_char
    done

    return
}



######################################################################
##  create_markdown ()
#

create_markdown () {

    # Create a new markdown file with title and optional table of contents

    if [[ $# != 6 ]] ; then
        echo "error: create_sh_script() requires 6 arguments"
        return 1
    fi

    directory=$1
    extension=$2
    name=$3
    overwrite=$4
    quiet=$5
    toc=$6

    filename=$3$'.'$2
    fullpath=$directory'/'$filename

    if [[ -e $fullpath ]] && ! $overwrite ; then
        echo "error: $fullpath already exists, use -f to overwrite"
        return 1
    fi

    string_out=

    make_title $name

    title=$string_out   # string out from make_title()

    title_len=${#title}

    spacer_size=$[65-$title_len]
    spacer=

    for i in $(seq 1 $spacer_size) ; do
        spacer="$spacer "
    done

    echo "\
######################################################################
#   $title$spacer#
######################################################################
"\
    > $fullpath

    if [[ !(-e $fullpath) ]]
    then
        echo "error: file not created"
        return 1
    fi

    if $toc ; then
        echo "\
# Table of Contents #

[TOC]
"\
        >> $fullpath
    fi

    if ! $quiet ; then
        echo "created file $fullpath"
    fi

    return
}



######################################################################
##  create_c_header ()
#

create_c_header () {

    # Create a new header with inclusion guards

    if [[ $# != 6 ]] ; then
        echo "error: create_c_header() requires 6 arguments"
        return 1
    fi

    directory=$1
    extension=$2
    name=$3
    overwrite=$4
    quiet=$5
    struct=$6

    filename=$3$'.'$2
    fullpath=$directory'/'$filename

    name_upper=$(echo $name | tr [:lower:] [:upper:])
    ext_upper=$(echo $extension | tr [:lower:] [:upper:])

    guard=$name_upper$'_'$ext_upper

    if [[ -e $fullpath ]] && ! $overwrite ; then
        echo "error: $fullpath already exists, use -f to overwrite"
        return 1
    fi

    echo "\
#ifndef $guard
#define $guard

#endif"\
    > $fullpath

    if [[ !(-e $fullpath) ]] ; then
        echo "error: file not created"
        return 1
    fi


    if $struct ; then

        head -n -1 $fullpath > $fullpath'.tmp'
        cat $fullpath'.tmp' > $fullpath
        rm $fullpath'.tmp'

        echo "\
struct $name;

struct $name
{

};

#endif"\
        >> $fullpath

    fi

    if ! $quiet ; then
        echo "created file $fullpath"
    fi

    return
}



######################################################################
##  create_c_src ()
#

create_c_src () {

    # Create a new source file with corresponding header inclusion

    if [[ $# != 10 ]] ; then
        echo "error: create_c_src() requires 10 arguments"
        return 1
    fi

    directory=$1
    extension=$2
    header_ext=$3
    name=$4
    overwrite=$5
    quiet=$6
    no_header=$7
    main=$8
    main_args=$9
    include_io=${10}

    filename=$4$'.'$2
    fullpath=$directory'/'$filename

    if [[ -e $fullpath ]] && ! $overwrite ; then
        echo "error: $fullpath already exists, use -f to overwrite"
        return 1
    fi

    echo -n > $fullpath

    if ! $no_header ; then
        echo "\
#include \"$name.$header_ext\""\
        > $fullpath
    fi

    if [[ !(-e $fullpath) ]] ; then
        echo "error: file not created"
        return 1
    fi

    if $include_io ; then

        if ! $no_header ; then
            echo "" >> $fullpath
        fi

        case $extension in

            c)
                echo "\
#include <stdio.h>"\
                >> $fullpath
            ;;

            cc|cpp)
                echo "\
#include <iostream>"\
                >> $fullpath
            ;;

            *)
                echo "error: create_c_header() unrecognized filetype"
                return 1
            ;;

        esac
    fi

    if $main ; then

        if ! $no_header || $include_io ; then
            echo "" >> $fullpath
        fi

        case $extension in

            c)
                case $main_args in

                    v|vo|voi|void)
                        echo "\
int main(void)"\
                        >> $fullpath
                    ;;

                    a|ar|arg|args)
                        echo "\
int main(int argc, char *argv[])"\
                        >> $fullpath
                    ;;

                    *)
                        echo "error: create_c_src() \$main_args not valid"
                        return 1
                    ;;

                esac
            ;;

            cc|cpp)
                case $main_args in

                    v|vo|voi|void)
                        echo "\
int main()"\
                        >> $fullpath
                    ;;

                    a|ar|arg|args)
                        echo "\
int main(int argc, char* argv[])"\
                        >> $fullpath
                    ;;

                    *)
                        echo "error: create_c_src() \$main_args not valid"
                        return 1
                    ;;

                esac
            ;;

            *)
                echo "error: create_c_src() extension not recognized"
                return 1
            ;;

        esac

        # body

        echo "\
{
    return 0;
}"\
        >> $fullpath

    fi

    if ! $quiet ; then
        echo "created file $fullpath"
    fi

    return
}



######################################################################
##  create_sh_script ()
#

create_sh_script () {

    # Create a new .sh file with bash shebang and execute permission.

    if [[ $# != 7 ]] ; then
        echo "error: create_sh_script() requires 7 arguments"
        return 1
    fi

    directory=$1
    extension=$2
    shell=$3
    name=$4
    overwrite=$5
    quiet=$6
    xtrace=$7

    filename=$4$'.'$2
    fullpath=$directory'/'$filename

    if [[ -e $fullpath ]] && ! $overwrite ; then
        echo "error: $fullpath already exists, use -f to overwrite"
        return 1
    fi

    echo "\
#!/bin/$shell"\
    > $fullpath

    if [[ !(-e $fullpath) ]]
    then
        echo "error: file not created"
        return 1
    fi

    if $xtrace ; then
        echo "\
set -x"\
        >> $fullpath
    fi

    echo "\

exit"\
    > $fullpath

    chmod +x $fullpath

    if ! $quiet ; then
        echo "created file $fullpath"
    fi

    return
}



######################################################################
##  main
#

if [[ $# < 1 ]] ; then
    echo "error: syntax is 'scrip <filename> [<filetype>] [flags]' or 'scrip -h' for help"
    exit 1

fi

case $1 in

    -h|--help)
        echo "$HELP"
        exit
    ;;

    *)
    ;;

esac

# options

genflags='efhq'
cflags='Him:stu'
mdflags='c'
shflags='xb:'
specflags=

# option flags flags

header=false
src=false
script=false
markdown=false
overwrite=false
quiet=false
struct=false
xtrace=false
main=false
include_io=false
open_editor=false
markdown_toc=false

# option arguments

shell='bash'
main_args='void'

# filenames

filename=$1
filetype=$2

directory=$(dirname "$filename")
filename=$(basename "$filename")
extension="${filename##*.}"
name="${filename%.*}"

# no-extension check

if [[ $extension == $filename ]] ; then
    extension=
fi

header_ext=
src_ext=
script_ext=
markdown_ext=

header_filename=
src_filename=
script_filename=
markdown_filename=

# check filetype

known_filetype=false

case $filetype in

    c|c++|cc|cpp|sh|md)
        known_filetype=true
    ;;

    *)
    ;;

esac

# extension

case $extension in

    # c

    c)
        src_ext='c'
        src=true
    ;;&

    h)
        header_ext='h'
        header=true
    ;;&

    c|h)
        if ! $known_filetype ; then
            filetype='c'
        fi
    ;;

    # c++

    cc)
        header_ext='hh'
        src_ext='cc'
    ;;&

    cpp)
        header_ext='hpp'
        src_ext='cpp'
    ;;&

    cc|cpp)
        src=true
    ;;&

    hh)
        header_ext='hh'
        src_ext='cc'
    ;;&

    hpp)
        header_ext='hpp'
        src_ext='cpp'
    ;;&

    hh|hpp)
        header=true
    ;;&

    cc|hh)
        if ! $known_filetype ; then
            filetype='cc'
        fi
    ;;&

    cpp|hpp)
        if ! $known_filetype ; then
            filetype='cpp'
        fi
    ;;

    # md

    md)
        markdown=true
        if ! $known_filetype ; then
            filetype='md'
        fi
    ;;

    # sh

    sh)
        script=true
        if ! $known_filetype ; then
            filetype='sh'
        fi
    ;;

    *)
    ;;

esac

# filetype

case $filetype in

    c)
        header_ext='h'
        src_ext='c'
    ;;&

    cc)
        if [[ $header_ext == '' || $extension == $src_ext ]] ; then
            header_ext='hh'
        else
            header_ext=$extension
        fi
        if [[ $src_ext == '' ]] ; then
            src_ext='cc'
        fi
    ;;&

    c++|cpp)
        if [[ $header_ext == '' || $extension == $src_ext ]] ; then
            header_ext='hpp'
        else
            header_ext=$extension
        fi
        if [[ $src_ext == '' ]] ; then
            src_ext='cpp'
        fi
    ;;&

    c|c++|cc|cpp)
        specflags=$cflags
    ;;

    md)
        specflags=$mdflags
        markdown=true
        markdown_ext='md'
    ;;

    sh)
        specflags=$shflags
        script=true
        script_ext='sh'
    ;;

    *)
        echo "error: could not determine filetype"
        exit 1
    ;;

esac

# filenames

header_filename=$name'.'$header_ext
src_filename=$name'.'$src_ext
script_filename=$name'.'$script_ext
markdown_filename=$name'.'$markdown_ext

header_fullpath=$directory'/'$header_filename
src_fullpath=$directory'/'$src_filename
script_fullpath=$directory'/'$script_filename
markdown_fullpath=$directory'/'$markdown_filename

# process flags

flags_found=false

no_header_flag=true

while (($OPTIND <= $#)) ; do

    while getopts $genflags$specflags o ; do

        flags_found=true

        case $o in

            b)
                shell=$OPTARG
            ;;

            c)
                markdown_toc=true
            ;;

            e)
                open_editor=true
            ;;

            f)
                overwrite=true
            ;;

            H)
                no_header_flag=false
                header=true
            ;;

            i)
                include_io=true
            ;;

            m)
                main=true
                main_args=$OPTARG
            ;;

            q)
                quiet=true
            ;;

            s)
                src=true
            ;;

            t)
                struct=true
            ;;

            u)
                no_header_flag=false
                header=true
                src=true
                unit=true
            ;;

            x)
                xtrace=true
            ;;

            h)
                echo "\
ignoring -h: use -H for headers
help syntax: scrip -h, scrip --help"
            ;;

        esac

    done

    OPTIND=$((OPTIND+1))

done

# catch main

if [[ $name == 'main' ]] ; then
    main=true
    include_io=true
fi

# if no flag or extension was provided, set defaults

if ! $header && ! $src && ! $script ; then
    case $filetype in

        c++|c|cc|cpp)   # default c family: create compilation unit

            if [[ $name != 'main' ]] ; then
                header=true
            fi

            if [[ $name == 'main' ]] ; then
                include_io=true
            fi

            src=true
        ;;

        md)         # default markdown: create markdown
            markdown=true
        ;;

        sh)         # default shell: create script
            script=true
        ;;

    esac
fi

# messages for invalid options

if ! $src && $include_io ; then
    echo "warning: include io specified but no source file created"
fi

if ! $src && $main ; then
    echo "warning: main specified but no source file created"
fi

if ! $header && $struct ; then
    echo "ignoring -t struct: no header file created"
fi

# file creation

header_created=

if $header ; then
    create_c_header $directory $header_ext $name $overwrite $quiet $struct

    header_created=$directory'/'$name'.'$header_ext
fi

if $src ; then

    no_header=false

    if [[ $name == 'main' ]] ; then
        no_header=$no_header_flag
    fi

    create_c_src $directory $src_ext $header_ext $name $overwrite $quiet $no_header $main $main_args $include_io

    src_created=$directory'/'$name'.'$src_ext
fi

if $markdown ; then

    create_markdown $directory $markdown_ext $name $overwrite $quiet $markdown_toc
    markdown_created=$directory'/'$name'.'$markdown_ext

fi

if $script ; then

    create_sh_script $directory $script_ext $shell $name $overwrite $quiet $xtrace

    script_created=$directory'/'$name'.'$script_ext
fi

if $open_editor; then
    vim $header_created $src_created $script_created
fi

# exit

exit
